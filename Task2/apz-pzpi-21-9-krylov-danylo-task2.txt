1 ХІД РОБОТИ
1.1	Концептуальне моделювання предметної області


Концептуальне моделювання предметної області є важливим етапом в процесі розробки інформаційної системи. Воно дозволяє зрозуміти основні сутності, процеси та взаємозв'язки між ними в межах досліджуваної області. На цьому етапі створюється концептуальна модель, яка наочно відображає структуру системи та її функціональні можливості.
На рисунку 1.1 представлена діаграма варіантів використання (use case diagram), яка демонструє ключові функціональні можливості системи управління складом. Ця діаграма включає основні дії, які може виконувати користувач системи, а також додаткові функції, що розширюють базові операції.

 
Рисунок 1.1 – Діаграма варіантів використання.

Опис елементів діаграми:
Актор – користувач системи:
	Представлений у вигляді фігури людини в центрі діаграми.
	Це може бути адміністратор складу, який має доступ до всіх функціональних можливостей системи.
Варіанти використання:
Перегляд інформації:
	Основна функція, яка дозволяє користувачеві переглядати дані про товари, замовлення, користувачів тощо.
	Цей варіант використання розширюється (extend) додатковими можливостями, такими як сортування, фільтрація та пошук інформації.
Сортування:
Дозволяє впорядкувати інформацію за певними критеріями (наприклад, за датою, ціною, назвою).
Фільтрація:
Дозволяє відбирати інформацію за певними умовами (наприклад, тільки доступні товари, товари зі знижкою).
Пошук:
Дозволяє знаходити конкретні записи в системі за ключовими словами або іншими параметрами.
Додавання інформації:
Дозволяє користувачеві вводити нові дані в систему (наприклад, нові товари, нові замовлення).
Редагування інформації:
Дозволяє змінювати існуючі дані в системі.
Видалення інформації:
Дозволяє видаляти записи з системи.
Аналіз інформації:
Дозволяє користувачеві проводити аналітичні операції з даними, отримувати статистичну інформацію.
Розширюється можливостями створення звітів та запитів на статистику.
Звіти:
Генерація різних звітів на основі даних системи (наприклад, звіти про продажі, звіти про залишки товарів на складі).
Запити на статистику:
Дозволяє отримувати детальні статистичні дані на основі наявної інформації.
Автоматизація:
Дозволяє автоматизувати певні процеси в системі (наприклад, автоматичне оновлення залишків, сповіщення про необхідність поповнення запасів).
Концептуальне моделювання на основі діаграми варіантів використання дозволяє чітко визначити функціональні вимоги до системи управління складом, забезпечити зрозуміле та структуроване уявлення про її можливості та взаємодію користувача з системою. Це є важливим кроком для подальшого проєктування та розробки програмного забезпечення.


1.2 Опис побудови бази даних


Структура сутностей.
На рисунку 1.2 представлена ER-діаграма, яка відображає структуру бази даних системи управління складом. Кожна сутність в діаграмі представляє таблицю в базі даних, а атрибути сутностей відповідають стовпцям цих таблиць.

 
Рисунок 1.2 – ER-діаграма.

Товари:
	товар айді (bigint): Унікальний ідентифікатор товару.
	назва (varchar): Назва товару.
	опис (text): Опис товару.
	ціна (decimal): Ціна товару.
	знижка (decimal): Розмір знижки на товар.
	дата створення (timestamp): Дата створення запису.
	доступність кредитування (boolean): Показник, чи доступний товар для покупки в кредит.
	маса (decimal): Маса товару.
	габарити (varchar): Розміри товару.
	умови зберігання (text): Умови зберігання товару.
	гарантія (varchar): Інформація про гарантію на товар.
Ряди:
	ряд айді (bigint): Унікальний ідентифікатор ряду.
	номер ряду (bigint): Номер ряду в складі.
	номер початку місця (bigint): Номер місця початку ряду.
	кількість (bigint): Кількість місць в ряду.
Корзини:
	корзина айді (bigint): Унікальний ідентифікатор корзини.
	дата створення (timestamp): Дата створення корзини.
	статус (varchar): Статус корзини (активна, завершена тощо).
Покупці:
	покупець айді (bigint): Унікальний ідентифікатор покупця.
	ім'я (varchar): Ім'я покупця.
	прізвище (varchar): Прізвище покупця.
	по батькові (varchar): По батькові покупця.
	дата реєстрації (timestamp): Дата реєстрації покупця в системі.
	стать (varchar): Стать покупця.
	адреса (varchar): Адреса покупця.
	дата народження (date): Дата народження покупця.
	пошта (varchar): Електронна пошта покупця.
Покупки:
	дата додавання (timestamp): Дата додавання покупки.
	кількість (bigint): Кількість товарів у покупці.
	Способи доставки:
	спосіб доставки айді (bigint): Унікальний ідентифікатор способу доставки.
	назва способу (varchar): Назва способу доставки.
	дата створення (timestamp): Дата створення запису про спосіб доставки.
Категорії:
	категорія айді (bigint): Унікальний ідентифікатор категорії.
	назва категорії (varchar): Назва категорії.
	дата створення (timestamp): Дата створення запису про категорію.
ТовариСпособиДоставки:
	ТоварСпосібДоставки айді (bigint): Унікальний ідентифікатор зв'язку між товаром та способом доставки.
ТовариКатегорії:
	ТоварКатегоріяАйді (bigint): Унікальний ідентифікатор зв'язку між товаром та категорією.
Зв'язки між сутностями:
ER-діаграма на рисунку 1.2 також показує зв'язки між сутностями:
Покупці та Покупки:
Зв'язок між таблицею покупці та таблицею покупки відображає, що кожен покупець може мати декілька покупок.
Корзини та Покупки:
Зв'язок між таблицею корзини та таблицею покупки показує, що кожна корзина може містити декілька покупок.
Товари та Ряди:
Зв'язок між таблицею товари та таблицею ряди відображає, що кожен товар може зберігатися в певному ряду складу.
Товари та ТовариКатегорії:
Зв'язок між таблицею товари та таблицею ТовариКатегорії показує, що кожен товар може належати до кількох категорій.
Товари та ТовариСпособиДоставки:
Зв'язок між таблицею товари та таблицею ТовариСпособиДоставки відображає, що кожен товар може бути доставлений різними способами.
ТовариКатегорії та Категорії:
Зв'язок між таблицею ТовариКатегорії та таблицею категорії показує, що кожна категорія може включати декілька товарів.
ТовариСпособиДоставки та Способи Доставки:
Зв'язок між таблицею ТовариСпособиДоставки та таблицею способи доставки показує, що кожен спосіб доставки може бути застосований до декількох товарів.

1.3 Серверна частина


Наведемо структуру проекту на діаграмі пакетів (див. рис. 1.3).

 
Рисунок 1.3 – Діаграма пакетів

Використані технології та їх особливості:
Мова програмування та фреймворк:
C# та ASP.NET Core: Основною мовою програмування є C#, а для розробки веб-API використовується фреймворк ASP.NET Core. Це дозволяє створювати високопродуктивні та масштабовані веб-додатки.
Обробка запитів та відповіді:
Контролери: Використання контролерів для обробки HTTP-запитів. Наприклад, Cards Controller обробляє запити для роботи з картками товарів на складі.
Атрибути маршрутизації: Використання атрибутів [Route] та [HttpGet], [HttpPost], [HttpPut], [HttpDelete] для визначення маршрутів та типів HTTP-запитів.
Зв'язок з базою даних:
Entity Framework Core: Використовується для взаємодії з базою даних. Це ORM, який дозволяє працювати з базою даних за допомогою C# об'єктів. Методи, такі як Include та ToListAsync, дозволяють виконувати асинхронні запити до бази даних та завантажувати пов'язані дані.
Асинхронні операції:
Асинхронне програмування: Використання ключових слів async та await для забезпечення асинхронного виконання операцій, що покращує продуктивність та масштабованість додатка.
Розглянемо приклад контролеру CardsController, який реалізовано за допомогою ASP.NET Core. Цей контролер забезпечує CRUD-операції (створення, читання, оновлення, видалення) для управління картками товарів на складі. Він використовує Entity Framework Core для взаємодії з базою даних, що дозволяє виконувати асинхронні запити та маніпуляції з даними. Використання атрибутів, таких як [HttpGet], [HttpPost], [HttpPut], [HttpDelete], визначає маршрути та типи HTTP-запитів для кожного методу контролера.
Наприклад, метод GetCards повертає список всіх карток з включеними пов'язаними даними про продукти та магазинні картки.
Цей підхід дозволяє ефективно керувати даними та забезпечує масштабованість та продуктивність системи управління складом.


1.4 REST специфікація


Cards
GET /api/Cards - Отримати список карток.
GET /api/Cards/{id} - Отримати деталі картки за ідентифікатором.
POST /api/Cards - Створити нову картку.
PUT /api/Cards/{id} - Оновити картку за ідентифікатором.
DELETE /api/Cards/{id} - Видалити картку за ідентифікатором.
Categories
GET /api/Categories - Отримати список категорій.
GET /api/Categories/{id} - Отримати деталі категорії за ідентифікатором.
POST /api/Categories - Створити нову категорію.
PUT /api/Categories/{id} - Оновити категорію за ідентифікатором.
DELETE /api/Categories/{id} - Видалити категорію за ідентифікатором.
DeliveryMethodProducts
GET /api/DeliveryMethodProducts - Отримати список продуктів методів доставки.
GET /api/DeliveryMethodProducts/{id} - Отримати деталі продукту методу доставки за ідентифікатором.
POST /api/DeliveryMethodProducts - Створити новий продукт методу доставки.
PUT /api/DeliveryMethodProducts/{id} - Оновити продукт методу доставки за ідентифікатором.
DELETE /api/DeliveryMethodProducts/{id} - Видалити продукт методу доставки за ідентифікатором.
DeliveryMethods
GET /api/DeliveryMethods - Отримати список методів доставки.
GET /api/DeliveryMethods/{id} - Отримати деталі методу доставки за ідентифікатором.
POST /api/DeliveryMethods - Створити новий метод доставки.
PUT /api/DeliveryMethods/{id} - Оновити метод доставки за ідентифікатором.
DELETE /api/DeliveryMethods/{id} - Видалити метод доставки за ідентифікатором.
ProductCategories
GET /api/ProductCategories - Отримати список категорій продуктів.
GET /api/ProductCategories/{id} - Отримати деталі категорії продукту за ідентифікатором.
POST /api/ProductCategories - Створити нову категорію продукту.
PUT /api/ProductCategories/{id} - Оновити категорію продукту за ідентифікатором.
DELETE /api/ProductCategories/{id} - Видалити категорію продукту за ідентифікатором.
Products
GET /api/Products - Отримати список продуктів.
GET /api/Products/{id} - Отримати деталі продукту за ідентифікатором.
POST /api/Products - Створити новий продукт.
PUT /api/Products/{id} - Оновити продукт за ідентифікатором.
DELETE /api/Products/{id} - Видалити продукт за ідентифікатором.
Rows
GET /api/Rows - Отримати список рядів.
GET /api/Rows/{id} - Отримати деталі ряду за ідентифікатором.
POST /api/Rows - Створити новий ряд.
PUT /api/Rows/{id} - Оновити ряд за ідентифікатором.
DELETE /api/Rows/{id} - Видалити ряд за ідентифікатором.
ShopCards
GET /api/ShopCards - Отримати список магазинних карток.
GET /api/ShopCards/{id} - Отримати деталі магазинної картки за ідентифікатором.
POST /api/ShopCards - Створити нову магазинну картку.
PUT /api/ShopCards/{id} - Оновити магазинну картку за ідентифікатором.
DELETE /api/ShopCards/{id} - Видалити магазинну картку за ідентифікатором.
Users
GET /api/Users - Отримати список користувачів.
GET /api/Users/{id} - Отримати деталі користувача за ідентифікатором.
POST /api/Users - Створити нового користувача.
PUT /api/Users/{id} - Оновити користувача за ідентифікатором.
DELETE /api/Users/{id} - Видалити користувача за ідентифікатором.
 
ВИСНОВКИ


Розробка системи управління складом на базі ASP.NET Core дозволяє створювати високопродуктивні, масштабовані та ефективні веб-додатки для управління складськими операціями. Використання сучасних технологій, таких як Entity Framework Core, забезпечує зручний та продуктивний спосіб взаємодії з базою даних, дозволяючи виконувати асинхронні запити та маніпуляції з даними.
Система включає різні контролери для управління картками, категоріями, продуктами, методами доставки, рядами, магазинними картками та користувачами. Кожен контролер забезпечує CRUD-операції, що спрощує управління різними аспектами складу. Використання атрибутів маршрутизації та асинхронного програмування сприяє підвищенню продуктивності та надійності системи.
Загалом, така система управління складом дозволяє оптимізувати складські операції, забезпечити надійне зберігання та управління даними, а також покращити загальну ефективність роботи складу.
 
ДОДАТОК А
Код CardsController


1	[Route("api/[controller]")]
2	    [ApiController]
3	    public class CardsController : ControllerBase
4	    {
5	        private readonly DataContext _context;
6	
7	        public CardsController(DataContext context)
8	        {
9	            _context = context;
10	        }
11	
12	        // GET: api/Cards
13	        [HttpGet]
14	        public async Task<ActionResult<IEnumerable<Card>>> GetCards()
15	        {
16	            return await _context.Cards.Include(c => c.Product).Include(c => c.ShopCard).ToListAsync();
17	        }
18	
19	        // GET: api/Cards/5
20	        [HttpGet("{id}")]
21	        public async Task<ActionResult<Card>> GetCard(int id)
22	        {
23	            var card = await _context.Cards.Include(c => c.Product).Include(c => c.ShopCard).FirstOrDefaultAsync(c => c.CardId == id);
24	            if (card == null)
25	            {
26	                return NotFound();
27	            }
28	
29	            return card;
30	        }
31	
32	        // POST: api/Cards
33	        [HttpPost]
34	        public async Task<ActionResult<Card>> PostCard(Card card)
35	        {
36	            Product product = await _context.Products.Include(p => p.Rows).FirstOrDefaultAsync(p => p.ProductId == card.ProductId);
37	            if (product.Rows.Sum(r => r.Quantity) < card.Quantity)
38	            {
39	                return BadRequest("There are not so many goods in stock");
40	            }
41	
42	            _context.Cards.Add(card);
43	            await _context.SaveChangesAsync();
44	
45	            return CreatedAtAction("GetCard", new { id = card.CardId }, card);
46	        }
47	
48	        // PUT: api/Cards/5
49	        [HttpPut("{id}")]
50	        public async Task<IActionResult> PutCard(int id, Card card)
51	        {
52	            if (id != card.CardId)
53	            {
54	                return BadRequest();
55	            }
56	
57	            Product product = await _context.Products.Include(p => p.Rows).FirstOrDefaultAsync(p => p.ProductId == card.ProductId);
58	            if (product.Rows.Sum(r => r.Quantity) < card.Quantity)
59	            {
60	                return BadRequest("There are not so many goods in stock");
61	            }
62	
63	            _context.Entry(card).State = EntityState.Modified;
64	
65	            try
66	            {
67	                await _context.SaveChangesAsync();
68	            }
69	            catch (DbUpdateConcurrencyException)
70	            {
71	                if (!CardExists(id))
72	                {
73	                    return NotFound();
74	                }
75	                else
76	                {
77	                    throw;
78	                }
79	            }
80	
81	            return NoContent();
82	        }
83	
84	        // DELETE: api/Cards/5
85	        [HttpDelete("{id}")]
86	        public async Task<IActionResult> DeleteCard(int id)
87	        {
88	            var card = await _context.Cards.FindAsync(id);
89	            if (card == null)
90	            {
91	                return NotFound();
92	            }
93	
94	            _context.Cards.Remove(card);
95	            await _context.SaveChangesAsync();
96	
97	            return NoContent();
98	        }
99	
100	        private bool CardExists(int id)
101	        {
102	            return _context.Cards.Any(e => e.CardId == id);
103	        }
104	    }
